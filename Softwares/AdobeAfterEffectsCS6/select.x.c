#if 0
	shc Version 4.0.1, Generic Shell Script Compiler
	GNU GPL Version 3 Md Jahidul Hamid <jahidulhamid@yahoo.com>

	shc -f select -o select 
#endif

static  char data [] = 
#define      chk2_z	19
#define      chk2	((&data[1]))
	"\247\261\035\130\103\217\316\314\046\046\013\073\203\110\074\113"
	"\112\063\065\140"
#define      rlax_z	1
#define      rlax	((&data[20]))
	"\124"
#define      msg1_z	65
#define      msg1	((&data[33]))
	"\146\001\346\205\101\346\014\013\300\235\337\224\044\246\305\146"
	"\256\152\302\055\344\330\112\351\015\211\131\371\143\337\133\346"
	"\213\304\033\334\204\275\366\343\252\076\054\365\021\235\130\047"
	"\360\172\341\224\041\246\224\353\055\373\233\146\126\357\312\123"
	"\242\211\155\373\257\322\076\045\346\254\350\253\111\201"
#define      pswd_z	256
#define      pswd	((&data[118]))
	"\021\075\040\245\202\036\011\223\306\273\055\270\324\347\310\073"
	"\350\257\301\143\126\277\251\327\023\211\215\370\220\320\367\166"
	"\253\003\157\173\165\320\356\262\203\332\073\053\236\271\173\014"
	"\173\134\157\321\033\030\251\056\242\066\047\063\007\037\252\262"
	"\042\031\056\230\352\034\113\155\366\207\230\225\100\023\241\273"
	"\160\021\215\213\052\066\272\315\155\342\000\164\001\252\046\044"
	"\304\125\275\256\161\010\033\150\220\263\376\320\307\237\214\070"
	"\261\031\304\333\120\176\250\275\140\251\061\142\123\130\206\030"
	"\255\103\306\037\114\342\210\334\226\206\254\135\045\071\226\327"
	"\122\132\262\242\330\132\137\071\003\221\233\127\351\042\157\226"
	"\145\066\266\261\030\076\216\256\304\073\014\352\164\242\301\307"
	"\374\163\151\325\316\311\017\322\132\252\052\104\315\231\333\062"
	"\320\221\344\350\317\162\227\223\256\243\175\042\106\077\351\103"
	"\262\123\031\201\034\050\123\167\323\175\274\240\027\227\323\347"
	"\050\267\320\367\052\147\213\330\013\010\373\121\110\344\225\373"
	"\067\256\174\124\326\320\314\252\116\210\112\146\037\035\116\110"
	"\325\036\077\000\206\312\331\221\323\324\343\033\270\170\026\360"
	"\046\223\104\052\225\315\066\125\153\025\352\355\020\067\347\042"
	"\165\010\310\370\046\321\214\354\215\271\245\142\241\156\235\212"
	"\035\137\264\263\054\352\011\230\000\363\205\020\053\154\063\240"
	"\165\373\230\233\315\045\210\132\337\056\274\200\234\132\012\271"
	"\271\277"
#define      lsto_z	1
#define      lsto	((&data[437]))
	"\003"
#define      tst1_z	22
#define      tst1	((&data[440]))
	"\151\004\334\255\046\273\341\001\357\203\017\014\356\007\365\127"
	"\116\141\073\303\122\014\370\033\272\224\161"
#define      tst2_z	19
#define      tst2	((&data[466]))
	"\352\274\150\062\102\212\342\254\010\067\170\306\365\136\200\037"
	"\335\054\062\134\316\202\267\363"
#define      date_z	1
#define      date	((&data[489]))
	"\233"
#define      shll_z	10
#define      shll	((&data[492]))
	"\325\050\161\144\016\240\001\351\001\322\155\244"
#define      xecc_z	15
#define      xecc	((&data[504]))
	"\034\373\011\070\212\343\145\141\321\376\102\161\233\122\322\056"
	"\265\310\306\161"
#define      inlo_z	3
#define      inlo	((&data[522]))
	"\023\352\243"
#define      chk1_z	22
#define      chk1	((&data[526]))
	"\275\165\057\120\100\360\132\167\051\310\221\202\007\022\144\233"
	"\062\033\161\046\344\322\175\032\244"
#define      msg2_z	19
#define      msg2	((&data[550]))
	"\113\253\170\371\040\036\024\173\140\173\012\366\351\375\113\070"
	"\372\314\062\045\273"
#define      opts_z	1
#define      opts	((&data[571]))
	"\352"
#define      text_z	814
#define      text	((&data[655]))
	"\213\076\303\351\315\245\005\310\155\314\072\265\075\025\000\150"
	"\204\276\202\050\141\206\233\207\102\001\270\016\071\041\251\305"
	"\137\154\256\055\021\263\366\177\200\060\064\275\105\065\046\311"
	"\363\250\362\125\057\215\335\161\216\225\200\310\266\052\215\026"
	"\226\073\103\250\357\071\050\157\152\134\055\257\222\123\170\205"
	"\373\153\333\315\131\353\023\107\002\335\205\320\265\317\070\231"
	"\261\351\123\006\053\244\142\372\075\173\026\364\220\332\160\041"
	"\211\067\171\310\302\007\273\341\312\055\267\371\160\144\272\322"
	"\014\040\373\026\367\304\151\061\270\201\320\077\225\266\123\046"
	"\165\205\373\217\317\053\236\245\117\164\174\036\335\174\253\371"
	"\041\327\302\037\364\307\160\042\045\335\227\140\313\175\243\062"
	"\200\340\225\233\302\255\325\043\333\166\107\055\105\052\073\217"
	"\012\307\336\150\314\126\117\154\310\305\350\261\103\051\173\356"
	"\254\273\050\302\064\010\221\026\011\020\105\306\321\105\223\141"
	"\376\062\127\115\263\050\164\162\073\030\272\047\221\045\066\363"
	"\163\376\131\005\106\074\075\157\030\071\032\226\144\177\315\150"
	"\210\220\100\033\165\370\245\061\023\043\314\375\065\102\322\030"
	"\070\302\263\041\363\356\247\026\022\012\077\101\061\373\246\226"
	"\010\375\367\105\332\305\211\062\151\254\242\046\207\236\204\236"
	"\376\117\005\141\305\237\111\367\025\265\123\365\154\014\115\341"
	"\247\357\114\343\301\343\002\025\243\100\320\110\216\270\270\034"
	"\361\062\131\201\034\066\211\023\115\362\217\255\213\317\373\054"
	"\265\046\122\372\345\333\314\252\042\024\115\156\242\117\325\150"
	"\214\151\306\252\336\325\275\040\173\013\066\022\056\065\052\135"
	"\052\210\322\067\103\175\127\037\320\242\262\125\074\226\300\331"
	"\324\175\013\027\303\355\026\301\050\077\167\237\043\036\144\035"
	"\315\167\204\042\151\374\264\225\261\056\046\000\235\367\210\034"
	"\366\357\252\042\374\071\313\020\113\103\262\170\031\025\365\224"
	"\214\126\342\344\107\122\166\100\301\315\342\101\024\267\244\053"
	"\221\200\000\107\305\044\016\277\133\341\352\005\256\113\261\017"
	"\012\161\042\065\262\002\056\025\055\223\200\362\350\076\352\204"
	"\204\034\333\160\141\111\051\220\355\010\013\065\205\277\156\104"
	"\032\205\243\217\327\066\173\237\126\370\051\201\166\004\174\053"
	"\101\067\031\126\200\142\007\015\041\175\127\215\115\143\374\117"
	"\143\165\317\211\155\210\043\151\205\121\003\045\105\214\306\252"
	"\124\141\103\201\241\173\167\361\274\315\222\232\276\253\254\272"
	"\336\237\026\076\226\067\337\053\221\216\200\377\031\214\032\140"
	"\365\167\131\374\104\070\223\151\267\035\127\124\277\240\363\230"
	"\133\001\220\163\341\363\257\203\233\211\223\356\157\225\066\233"
	"\133\046\347\257\227\221\321\215\273\375\327\172\113\353\222\100"
	"\154\043\133\367\044\045\110\242\010\236\007\266\360\136\073\240"
	"\337\252\374\140\245\316\037\036\226\374\342\255\014\161\061\176"
	"\001\236\156\237\376\172\352\075\077\335\305\142\246\272\332\212"
	"\026\101\366\034\026\243\217\175\135\163\134\055\242\104\371\345"
	"\311\150\132\304\010\006\125\032\204\171\072\052\130\327\003\052"
	"\066\006\305\064\221\002\332\127\117\356\342\335\015\127\012\277"
	"\340\036\134\041\332\053\225\223\011\275\052\103\041\320\305\364"
	"\021\156\127\130\302\116\075\172\340\305\206\347\211\274\001\232"
	"\003\107\107\171\056\147\216\340\007\370\152\265\107\363\267\243"
	"\214\256\055\012\274\062\337\211\137\065\032\217\350\000\343\152"
	"\164\043\270\055\275\052\237\204\014\017\211\242\102\051\221\231"
	"\307\023\061\124\353\236\216\227\343\363\201\357\105\332\052\162"
	"\324\231\002\162\360\330\027\105\006\026\174\167\166\173\106\144"
	"\216\224\153\170\245\225\120\316\021\225\016\206\257\044\116\011"
	"\023\140\172\023\357\240\332\101\014\303\057\010\315\274\374\254"
	"\010\154\051\005\012\100\074\310\352\007\172\015\302\006\307\305"
	"\334\053\370\270\235\206\115\035\116\004\107\334\032\336\027\136"
	"\206\006\227\257\165\002\013\242\261\236\366\052\043\362\225\377"
	"\035\215\267\272\024\005\330\143\011\037\077\044\376\127\202\205"
	"\135\032\064\323\034\100\166\315\336\154\370\002\136\215\001\174"
	"\033\271\066\060\276\016\223\310\056\323\354\054\052\156\261\210"
	"\210\346\133\245\046\321\163\004\076\153\006\234\370\010\030\023"
	"\301\117\104\177\136\327\107\215\253\064\272\326\242\154\136\053"
	"\122\272\320\170\214\103\175\312\256\203\147\247"/* End of data[] */;
#define      hide_z	4096
#define SETUID 0	/* Define as 1 to call setuid(0) at start of script */
#define DEBUGEXEC	0	/* Define as 1 to debug execvp calls */
#define TRACEABLE	1	/* Define as 1 to enable ptrace the executable */
#define HARDENING	0	/* Define as 1 to disable ptrace/dump the executable */
#define HARDENINGSP	0	/* Define as 1 to disable bash child process */
#define BUSYBOXON	0	/* Define as 1 to enable work with busybox */

/* rtc.c */

#include <sys/stat.h>
#include <sys/types.h>

#include <errno.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <time.h>
#include <unistd.h>

/* 'Alleged RC4' */

static unsigned char stte[256], indx, jndx, kndx;

/*
 * Reset arc4 stte. 
 */
void stte_0(void)
{
	indx = jndx = kndx = 0;
	do {
		stte[indx] = indx;
	} while (++indx);
}

/*
 * Set key. Can be used more than once. 
 */
void key(void * str, int len)
{
	unsigned char tmp, * ptr = (unsigned char *)str;
	while (len > 0) {
		do {
			tmp = stte[indx];
			kndx += tmp;
			kndx += ptr[(int)indx % len];
			stte[indx] = stte[kndx];
			stte[kndx] = tmp;
		} while (++indx);
		ptr += 256;
		len -= 256;
	}
}

/*
 * Crypt data. 
 */
void arc4(void * str, int len)
{
	unsigned char tmp, * ptr = (unsigned char *)str;
	while (len > 0) {
		indx++;
		tmp = stte[indx];
		jndx += tmp;
		stte[indx] = stte[jndx];
		stte[jndx] = tmp;
		tmp += stte[indx];
		*ptr ^= stte[tmp];
		ptr++;
		len--;
	}
}

/* End of ARC4 */

#if HARDENING

#include <sys/ptrace.h>
#include <sys/wait.h>
#include <signal.h>
#include <sys/prctl.h>
#define PR_SET_PTRACER 0x59616d61

/* Seccomp Sandboxing Init */
#include <stdlib.h>
#include <stdio.h>
#include <stddef.h>
#include <string.h>
#include <unistd.h>
#include <errno.h>

#include <sys/types.h>
#include <sys/prctl.h>
#include <sys/syscall.h>
#include <sys/socket.h>

#include <linux/filter.h>
#include <linux/seccomp.h>
#include <linux/audit.h>

#define ArchField offsetof(struct seccomp_data, arch)

#define Allow(syscall) \
    BPF_JUMP(BPF_JMP+BPF_JEQ+BPF_K, SYS_##syscall, 0, 1), \
    BPF_STMT(BPF_RET+BPF_K, SECCOMP_RET_ALLOW)

struct sock_filter filter[] = {
    /* validate arch */
    BPF_STMT(BPF_LD+BPF_W+BPF_ABS, ArchField),
    BPF_JUMP( BPF_JMP+BPF_JEQ+BPF_K, AUDIT_ARCH_X86_64, 1, 0),
    BPF_STMT(BPF_RET+BPF_K, SECCOMP_RET_KILL),

    /* load syscall */
    BPF_STMT(BPF_LD+BPF_W+BPF_ABS, offsetof(struct seccomp_data, nr)),

    /* list of allowed syscalls */
    Allow(exit_group),  /* exits a processs */
    Allow(brk),         /* for malloc(), inside libc */
    Allow(mmap),        /* also for malloc() */
    Allow(munmap),      /* for free(), inside libc */

    /* and if we don't match above, die */
    BPF_STMT(BPF_RET+BPF_K, SECCOMP_RET_KILL),
};
struct sock_fprog filterprog = {
    .len = sizeof(filter)/sizeof(filter[0]),
    .filter = filter
};

/* Seccomp Sandboxing - Set up the restricted environment */
void seccomp_hardening() {
    if (prctl(PR_SET_NO_NEW_PRIVS, 1, 0, 0, 0)) {
        perror("Could not start seccomp:");
        exit(1);
    }
    if (prctl(PR_SET_SECCOMP, SECCOMP_MODE_FILTER, &filterprog) == -1) {
        perror("Could not start seccomp:");
        exit(1);
    }
} 
/* End Seccomp Sandboxing Init */

void arc4_hardrun(void * str, int len) {
    //Decode locally
    char tmp2[len];
    memcpy(tmp2, str, len);

	unsigned char tmp, * ptr = (unsigned char *)tmp2;

    int lentmp = len;

#if HARDENINGSP
    //Start tracing to protect from dump & trace
    if (ptrace(PTRACE_TRACEME, 0, 0, 0) < 0) {
        printf("Operation not permitted\n");
        kill(getpid(), SIGKILL);
        exit(1);
    }

    //Decode Bash
    while (len > 0) {
        indx++;
        tmp = stte[indx];
        jndx += tmp;
        stte[indx] = stte[jndx];
        stte[jndx] = tmp;
        tmp += stte[indx];
        *ptr ^= stte[tmp];
        ptr++;
        len--;
    }

    //Exec bash script
    system(tmp2);

    //Empty script variable
    memcpy(tmp2, str, lentmp);

    //Sinal to detach ptrace
    ptrace(PTRACE_DETACH, 0, 0, 0);
    exit(0);

    /* Seccomp Sandboxing - Start */
    seccomp_hardening();

    exit(0);
#endif /* HARDENINGSP Exit here anyway*/

    int pid, status;
    pid = fork();

    if(pid==0) {

        //Start tracing to protect from dump & trace
        if (ptrace(PTRACE_TRACEME, 0, 0, 0) < 0) {
            printf("Operation not permitted\n");
            kill(getpid(), SIGKILL);
            _exit(1);
        }

        //Decode Bash
        while (len > 0) {
            indx++;
            tmp = stte[indx];
            jndx += tmp;
            stte[indx] = stte[jndx];
            stte[jndx] = tmp;
            tmp += stte[indx];
            *ptr ^= stte[tmp];
            ptr++;
            len--;
        }

        //Exec bash script
        system(tmp2);

        //Empty script variable
        memcpy(tmp2, str, lentmp);

        //Sinal to detach ptrace
        ptrace(PTRACE_DETACH, 0, 0, 0);
        exit(0);
    }
    else {
        wait(&status);
    }

    /* Seccomp Sandboxing - Start */
    seccomp_hardening();

    exit(0);
} 
#endif /* HARDENING */

/*
 * Key with file invariants. 
 */
int key_with_file(char * file)
{
	struct stat statf[1];
	struct stat control[1];

	if (stat(file, statf) < 0)
		return -1;

	/* Turn on stable fields */
	memset(control, 0, sizeof(control));
	control->st_ino = statf->st_ino;
	control->st_dev = statf->st_dev;
	control->st_rdev = statf->st_rdev;
	control->st_uid = statf->st_uid;
	control->st_gid = statf->st_gid;
	control->st_size = statf->st_size;
	control->st_mtime = statf->st_mtime;
	control->st_ctime = statf->st_ctime;
	key(control, sizeof(control));
	return 0;
}

#if DEBUGEXEC
void debugexec(char * sh11, int argc, char ** argv)
{
	int i;
	fprintf(stderr, "shll=%s\n", sh11 ? sh11 : "<null>");
	fprintf(stderr, "argc=%d\n", argc);
	if (!argv) {
		fprintf(stderr, "argv=<null>\n");
	} else { 
		for (i = 0; i <= argc ; i++)
			fprintf(stderr, "argv[%d]=%.60s\n", i, argv[i] ? argv[i] : "<null>");
	}
}
#endif /* DEBUGEXEC */

void rmarg(char ** argv, char * arg)
{
	for (; argv && *argv && *argv != arg; argv++);
	for (; argv && *argv; argv++)
		*argv = argv[1];
}

void chkenv_end(void);

int chkenv(int argc)
{
	char buff[512];
	unsigned long mask, m;
	int l, a, c;
	char * string;
	extern char ** environ;

	mask = (unsigned long)getpid();
	stte_0();
	 key(&chkenv, (void*)&chkenv_end - (void*)&chkenv);
	 key(&data, sizeof(data));
	 key(&mask, sizeof(mask));
	arc4(&mask, sizeof(mask));
	sprintf(buff, "x%lx", mask);
	string = getenv(buff);
#if DEBUGEXEC
	fprintf(stderr, "getenv(%s)=%s\n", buff, string ? string : "<null>");
#endif
	l = strlen(buff);
	if (!string) {
		/* 1st */
		sprintf(&buff[l], "=%lu %d", mask, argc);
		putenv(strdup(buff));
		return 0;
	}
	c = sscanf(string, "%lu %d%c", &m, &a, buff);
	if (c == 2 && m == mask) {
		/* 3rd */
		rmarg(environ, &string[-l - 1]);
		return 1 + (argc - a);
	}
	return -1;
}

void chkenv_end(void){}

#if HARDENING

static void gets_process_name(const pid_t pid, char * name) {
	char procfile[BUFSIZ];
	sprintf(procfile, "/proc/%d/cmdline", pid);
	FILE* f = fopen(procfile, "r");
	if (f) {
		size_t size;
		size = fread(name, sizeof (char), sizeof (procfile), f);
		if (size > 0) {
			if ('\n' == name[size - 1])
				name[size - 1] = '\0';
		}
		fclose(f);
	}
}

void hardening() {
    prctl(PR_SET_DUMPABLE, 0);
    prctl(PR_SET_PTRACER, -1);

    int pid = getppid();
    char name[256] = {0};
    gets_process_name(pid, name);

    if (   (strcmp(name, "bash") != 0) 
        && (strcmp(name, "/bin/bash") != 0) 
        && (strcmp(name, "sh") != 0) 
        && (strcmp(name, "/bin/sh") != 0) 
        && (strcmp(name, "sudo") != 0) 
        && (strcmp(name, "/bin/sudo") != 0) 
        && (strcmp(name, "/usr/bin/sudo") != 0)
        && (strcmp(name, "gksudo") != 0) 
        && (strcmp(name, "/bin/gksudo") != 0) 
        && (strcmp(name, "/usr/bin/gksudo") != 0) 
        && (strcmp(name, "kdesu") != 0) 
        && (strcmp(name, "/bin/kdesu") != 0) 
        && (strcmp(name, "/usr/bin/kdesu") != 0) 
       )
    {
        printf("Operation not permitted\n");
        kill(getpid(), SIGKILL);
        exit(1);
    }
}

#endif /* HARDENING */

#if !TRACEABLE

#define _LINUX_SOURCE_COMPAT
#include <sys/ptrace.h>
#include <sys/types.h>
#include <sys/wait.h>
#include <fcntl.h>
#include <signal.h>
#include <stdio.h>
#include <unistd.h>

#if !defined(PT_ATTACHEXC) /* New replacement for PT_ATTACH */
   #if !defined(PTRACE_ATTACH) && defined(PT_ATTACH)
       #define PT_ATTACHEXC	PT_ATTACH
   #elif defined(PTRACE_ATTACH)
       #define PT_ATTACHEXC PTRACE_ATTACH
   #endif
#endif

void untraceable(char * argv0)
{
	char proc[80];
	int pid, mine;

	switch(pid = fork()) {
	case  0:
		pid = getppid();
		/* For problematic SunOS ptrace */
#if defined(__FreeBSD__)
		sprintf(proc, "/proc/%d/mem", (int)pid);
#else
		sprintf(proc, "/proc/%d/as",  (int)pid);
#endif
		close(0);
		mine = !open(proc, O_RDWR|O_EXCL);
		if (!mine && errno != EBUSY)
			mine = !ptrace(PT_ATTACHEXC, pid, 0, 0);
		if (mine) {
			kill(pid, SIGCONT);
		} else {
			perror(argv0);
			kill(pid, SIGKILL);
		}
		_exit(mine);
	case -1:
		break;
	default:
		if (pid == waitpid(pid, 0, 0))
			return;
	}
	perror(argv0);
	_exit(1);
}
#endif /* !TRACEABLE */

char * xsh(int argc, char ** argv)
{
	char * scrpt;
	int ret, i, j;
	char ** varg;
	char * me = argv[0];
	if (me == NULL) { me = getenv("_"); }
	if (me == 0) { fprintf(stderr, "E: neither argv[0] nor $_ works."); exit(1); }

	ret = chkenv(argc);
	stte_0();
	 key(pswd, pswd_z);
	arc4(msg1, msg1_z);
	arc4(date, date_z);
	if (date[0] && (atoll(date)<time(NULL)))
		return msg1;
	arc4(shll, shll_z);
	arc4(inlo, inlo_z);
	arc4(xecc, xecc_z);
	arc4(lsto, lsto_z);
	arc4(tst1, tst1_z);
	 key(tst1, tst1_z);
	arc4(chk1, chk1_z);
	if ((chk1_z != tst1_z) || memcmp(tst1, chk1, tst1_z))
		return tst1;
	arc4(msg2, msg2_z);
	if (ret < 0)
		return msg2;
	varg = (char **)calloc(argc + 10, sizeof(char *));
	if (!varg)
		return 0;
	if (ret) {
		arc4(rlax, rlax_z);
		if (!rlax[0] && key_with_file(shll))
			return shll;
		arc4(opts, opts_z);
#if HARDENING
	    arc4_hardrun(text, text_z);
	    exit(0);
       /* Seccomp Sandboxing - Start */
       seccomp_hardening();
#endif
		arc4(text, text_z);
		arc4(tst2, tst2_z);
		 key(tst2, tst2_z);
		arc4(chk2, chk2_z);
		if ((chk2_z != tst2_z) || memcmp(tst2, chk2, tst2_z))
			return tst2;
		/* Prepend hide_z spaces to script text to hide it. */
		scrpt = malloc(hide_z + text_z);
		if (!scrpt)
			return 0;
		memset(scrpt, (int) ' ', hide_z);
		memcpy(&scrpt[hide_z], text, text_z);
	} else {			/* Reexecute */
		if (*xecc) {
			scrpt = malloc(512);
			if (!scrpt)
				return 0;
			sprintf(scrpt, xecc, me);
		} else {
			scrpt = me;
		}
	}
	j = 0;
#if BUSYBOXON
	varg[j++] = "busybox";
	varg[j++] = "sh";
#else
	varg[j++] = argv[0];		/* My own name at execution */
#endif
	if (ret && *opts)
		varg[j++] = opts;	/* Options on 1st line of code */
	if (*inlo)
		varg[j++] = inlo;	/* Option introducing inline code */
	varg[j++] = scrpt;		/* The script itself */
	if (*lsto)
		varg[j++] = lsto;	/* Option meaning last option */
	i = (ret > 1) ? ret : 0;	/* Args numbering correction */
	while (i < argc)
		varg[j++] = argv[i++];	/* Main run-time arguments */
	varg[j] = 0;			/* NULL terminated array */
#if DEBUGEXEC
	debugexec(shll, j, varg);
#endif
	execvp(shll, varg);
	return shll;
}

int main(int argc, char ** argv)
{
#if SETUID
   setuid(0);
#endif
#if DEBUGEXEC
	debugexec("main", argc, argv);
#endif
#if HARDENING
	hardening();
#endif
#if !TRACEABLE
	untraceable(argv[0]);
#endif
	argv[1] = xsh(argc, argv);
	fprintf(stderr, "%s%s%s: %s\n", argv[0],
		errno ? ": " : "",
		errno ? strerror(errno) : "",
		argv[1] ? argv[1] : "<null>"
	);
	return 1;
}
